import re
import logging
from flask import Flask, render_template, request, redirect, url_for, send_from_directory, jsonify
from app.main import create_highlights
from app.config import get_setting
from app.transcript_downloader import TranscriptDownloader
from app.transcript import TranscriptParser
from app.transcript_formatter import TranscriptFormatter, TranscriptFormat
import os
from pathlib import Path
import threading
import subprocess
from datetime import timedelta, datetime
import time
from typing import Dict, Optional
import uuid

logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

def convert_transcript_to_vtt(text_content):
    """Converts any transcript format to VTT using the enhanced formatter."""
    try:
        formatter = TranscriptFormatter()
        detected_format, confidence = formatter.detect_format(text_content)
        
        logger.info(f"Detected format: {detected_format.value} (confidence: {confidence:.2f})")
        
        if confidence > 0.3:  # If we have reasonable confidence
            vtt_content = formatter.convert_to_vtt(text_content, detected_format)
            return vtt_content, detected_format, confidence
        else:
            # Fallback to plain text conversion
            vtt_content = formatter.convert_to_vtt(text_content, TranscriptFormat.PLAIN_TEXT)
            return vtt_content, TranscriptFormat.PLAIN_TEXT, confidence
            
    except Exception as e:
        logger.error(f"Error in transcript conversion: {e}")
        # Ultimate fallback to original simple conversion
        return text_to_vtt_simple(text_content), TranscriptFormat.PLAIN_TEXT, 0.0

def text_to_vtt_simple(text_content):
    """Simple fallback VTT conversion (original function)"""
    vtt_lines = ["WEBVTT", ""]
    
    sentences = re.split(r'(?<=[.!?])\s*', text_content)
    sentences = [s.strip() for s in sentences if s.strip()]

    current_time = 0
    for sentence in sentences:
        start_seconds = current_time
        current_time += len(sentence.split()) * 0.5
        end_seconds = current_time

        start_time_str = f"{int(start_seconds // 3600):02d}:{int((start_seconds % 3600) // 60):02d}:{int(start_seconds % 60):02d}.000"
        end_time_str = f"{int(end_seconds // 3600):02d}:{int((end_seconds % 3600) // 60):02d}:{int(end_seconds % 60):02d}.000"

        vtt_lines.append(f"{start_time_str} --> {end_time_str}")
        vtt_lines.append(sentence)
        vtt_lines.append("")

    return "\n".join(vtt_lines)

# Task tracking for web interface
task_status: Dict[str, Dict] = {}

def get_video_id(url: str) -> Optional[str]:
    """Extract video ID from YouTube URL"""
    patterns = [
        r'(?:youtube\.com/watch\?v=|youtu\.be/|youtube\.com/embed/)([^&\n?#]+)',
        r'youtube\.com/v/([^&\n?#]+)',
        r'youtube\.com/watch\?.*?v=([^&\n?#]+)'
    ]
    
    for pattern in patterns:
        match = re.search(pattern, url)
        if match:
            return match.group(1)
    return None

def update_task_status(task_id: str, status: str, message: str = "", progress: int = 0, error: str = ""):
    """Update task status for web interface"""
    task_status[task_id] = {
        'status': status,  # 'pending', 'running', 'completed', 'failed'
        'message': message,
        'progress': progress,  # 0-100
        'error': error,
        'timestamp': datetime.now().isoformat()
    }
    logger.info(f"Task {task_id}: {status} - {message}")

def create_highlights_async(task_id: str, youtube_url: str, transcript_file: Optional[str] = None, 
                           manual_transcript: Optional[str] = None, description: str = "Generated by Web UI",
                           num_segments: int = 4, content_description: str = ""):
    """Async wrapper for create_highlights with status tracking"""
    try:
        update_task_status(task_id, 'running', 'Starting highlight generation', 10)
        
        # Handle transcript
        if manual_transcript:
            update_task_status(task_id, 'running', 'Processing manual transcript', 20)
            # Save manual transcript to temporary file
            cache_dir = Path(get_setting("cache_dir", ".cache"))
            cache_dir.mkdir(parents=True, exist_ok=True)
            
            video_id = get_video_id(youtube_url) or 'unknown'
            transcript_file = str(cache_dir / f"{video_id}_manual_{task_id}.vtt")
            
            # Convert to VTT if needed
            if not manual_transcript.strip().startswith("WEBVTT"):
                manual_transcript, detected_format, confidence = convert_transcript_to_vtt(manual_transcript)
                logger.info(f"Converted manual transcript from {detected_format.value} format (confidence: {confidence:.2f})")
            
            with open(transcript_file, 'w', encoding='utf-8') as f:
                f.write(manual_transcript)
                
        elif not transcript_file:
            update_task_status(task_id, 'running', 'Downloading transcript', 30)
            
            video_id = get_video_id(youtube_url)
            if not video_id:
                raise ValueError("Invalid YouTube URL")
            
            downloader = TranscriptDownloader()
            transcript_file = downloader.download_transcript(youtube_url, video_id)
            
            if not transcript_file:
                raise ValueError("Could not download transcript - video may not have subtitles")
        
        update_task_status(task_id, 'running', 'Creating highlights', 50)
        
        # Generate unique output directory
        timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
        output_base_dir = Path(get_setting("output_dir", "output"))
        unique_output_dir = output_base_dir / f"highlights_{timestamp}_{task_id[:8]}"
        unique_output_dir.mkdir(parents=True, exist_ok=True)
        
        # Create highlights with intelligent segment finding
        try:
            # Convert content description to keywords for backward compatibility
            keywords = None
            if content_description:
                from app.intelligent_segments import IntelligentSegmentFinder
                intelligent_finder = IntelligentSegmentFinder(content_description)
                keywords = intelligent_finder.key_concepts
            
            create_highlights(
                youtube_url=youtube_url,
                transcript_file=transcript_file,
                description=description,
                keywords=keywords,
                num_cards=num_segments,
                output_dir=str(unique_output_dir),
                content_description=content_description
            )
            
            # Check if HTML file was actually created
            html_file = unique_output_dir / "index.html"
            if html_file.exists():
                update_task_status(task_id, 'completed', f'Highlights generated successfully', 100)
                task_status[task_id]['output_dir'] = str(unique_output_dir)
                # Store relative path for web access
                relative_path = unique_output_dir.name + "/index.html"
                task_status[task_id]['html_path'] = relative_path
                task_status[task_id]['view_url'] = f"/output/{relative_path}"
            else:
                raise ValueError("HTML file was not generated - likely no interesting segments found")
                
        except Exception as create_error:
            # If create_highlights fails, we should still report the error properly
            raise create_error
        
    except Exception as e:
        logger.error(f"Task {task_id} failed: {e}")
        update_task_status(task_id, 'failed', 'Generation failed', 0, str(e))

app = Flask(__name__, template_folder='templates')

@app.route('/api/task/<task_id>')
def get_task_status(task_id: str):
    """Get task status via API"""
    if task_id in task_status:
        return jsonify(task_status[task_id])
    else:
        return jsonify({'error': 'Task not found'}), 404

@app.route('/api/detect-format', methods=['POST'])
def detect_transcript_format():
    """API endpoint to detect transcript format"""
    try:
        data = request.get_json()
        if not data or 'content' not in data:
            return jsonify({'error': 'No content provided'}), 400
        
        content = data['content']
        if not content.strip():
            return jsonify({'error': 'Empty content'}), 400
        
        formatter = TranscriptFormatter()
        detected_format, confidence = formatter.detect_format(content)
        format_info = formatter.get_format_info(detected_format)
        
        # Get preview of conversion
        preview = ""
        try:
            if confidence > 0.3:
                segments = formatter.parse_to_segments(content, detected_format)
                # Show first 3 segments as preview
                preview_segments = segments[:3]
                preview_lines = ["WEBVTT", ""]
                for segment in preview_segments:
                    start_time = formatter._seconds_to_vtt_time(segment.start)
                    end_time = formatter._seconds_to_vtt_time(segment.end)
                    preview_lines.extend([
                        f"{start_time} --> {end_time}",
                        segment.text,
                        ""
                    ])
                preview = "\n".join(preview_lines)
                
        except Exception as e:
            logger.warning(f"Could not generate preview: {e}")
        
        return jsonify({
            'format': detected_format.value,
            'confidence': confidence,
            'format_info': format_info,
            'preview': preview,
            'segments_found': len(formatter.parse_to_segments(content, detected_format)) if confidence > 0.3 else 0
        })
        
    except Exception as e:
        logger.error(f"Error in format detection API: {e}")
        return jsonify({'error': str(e)}), 500

@app.route('/', methods=['GET', 'POST'])
def index():
    if request.method == 'POST':
        youtube_url = request.form['youtube_url'].strip()
        video_id = get_video_id(youtube_url)
        
        if not video_id:
            return render_template('error.html', error="Invalid YouTube URL format"), 400
        
        # Get new form parameters
        num_segments = int(request.form.get('num_segments', 4))
        content_description = request.form.get('content_description', '').strip()
        description = request.form.get('description', '').strip() or "Generated by Web UI"
        
        # Validate parameters
        if num_segments < 1 or num_segments > 12:
            return render_template('error.html', error="Number of segments must be between 1 and 12"), 400
        
        if not content_description:
            return render_template('error.html', error="Please describe what content the segments should contain"), 400
        
        # Generate unique task ID
        task_id = str(uuid.uuid4())
        
        # Initialize task status
        update_task_status(task_id, 'pending', f'Initializing generation of {num_segments} segments')
        
        # Try to download transcript first
        try:
            downloader = TranscriptDownloader()
            transcript_file = downloader.download_transcript(youtube_url, video_id)
            
            if transcript_file:
                # Start highlights generation in background
                thread = threading.Thread(
                    target=create_highlights_async,
                    args=(task_id, youtube_url, transcript_file, None, description, num_segments, content_description)
                )
                thread.start()
                
                return render_template('processing.html', task_id=task_id, video_id=video_id)
            else:
                # No transcript available, redirect to manual input
                return redirect(url_for('manual_transcript_input', 
                                       youtube_url=youtube_url, 
                                       video_id=video_id, 
                                       task_id=task_id))
                
        except Exception as e:
            logger.error(f"Error processing request: {e}")
            return render_template('error.html', error=str(e)), 500
    
    return render_template('index.html')

@app.route('/manual_transcript', methods=['GET', 'POST'])
def manual_transcript_input():
    youtube_url = request.args.get('youtube_url')
    video_id = request.args.get('video_id')
    task_id = request.args.get('task_id') or str(uuid.uuid4())

    if request.method == 'POST':
        try:
            manual_transcript_content = request.form['transcript_content'].strip()
            
            if not manual_transcript_content:
                return render_template('error.html', error="Please provide transcript content"), 400
            
            # Validate transcript content first
            try:
                # Try to parse as-is to validate format
                if manual_transcript_content.startswith("WEBVTT") or \
                   re.match(r'^\d+\s*\n\d{2}:\d{2}:\d{2}[,.:]\d{3} --> \d{2}:\d{2}:\d{2}[,.:]\d{3}', manual_transcript_content, re.MULTILINE):
                    logger.info("Manual transcript is in structured format")
                    processed_transcript = manual_transcript_content
                else:
                    logger.info("Converting transcript to VTT format")
                    processed_transcript, detected_format, confidence = convert_transcript_to_vtt(manual_transcript_content)
                    logger.info(f"Detected format: {detected_format.value} (confidence: {confidence:.2f})")
                
                # Validate by parsing
                cache_dir = Path(get_setting("cache_dir", ".cache"))
                cache_dir.mkdir(parents=True, exist_ok=True)
                temp_file = cache_dir / f"temp_validation_{task_id}.vtt"
                
                with open(temp_file, 'w', encoding='utf-8') as f:
                    f.write(processed_transcript)
                
                # Test parsing
                segments = TranscriptParser.parse(temp_file)
                if not segments:
                    temp_file.unlink()
                    return render_template('error.html', error="Could not parse transcript - please check format"), 400
                
                temp_file.unlink()
                logger.info(f"Successfully validated transcript with {len(segments)} segments")
                
            except Exception as e:
                logger.error(f"Transcript validation failed: {e}")
                return render_template('error.html', error=f"Invalid transcript format: {e}"), 400
            
            # Start highlights generation with manual transcript
            # TODO: Pass through form parameters from main form
            thread = threading.Thread(
                target=create_highlights_async,
                args=(task_id, youtube_url, None, processed_transcript, "Generated by Web UI (Manual Transcript)", 4, "Find key concepts, important points, examples, and educational content")
            )
            thread.start()

            return render_template('processing.html', task_id=task_id, video_id=video_id)
            
        except Exception as e:
            logger.error(f"Error processing manual transcript: {e}")
            return render_template('error.html', error=str(e)), 500

    return render_template('manual_transcript.html', 
                         youtube_url=youtube_url, 
                         video_id=video_id, 
                         task_id=task_id)

@app.route('/results')
def results_list():
    """Show all previously generated highlight pages"""
    try:
        output_dir = Path(get_setting("output_dir", "output"))
        if not output_dir.exists():
            return render_template('error.html', error="Output directory not found"), 404
        
        # Find all highlight directories
        highlight_dirs = []
        for item in output_dir.iterdir():
            if item.is_dir() and item.name.startswith('highlights_'):
                html_file = item / "index.html"
                if html_file.exists():
                    # Extract timestamp from directory name
                    parts = item.name.split('_')
                    if len(parts) >= 3:
                        try:
                            timestamp_str = f"{parts[1]}_{parts[2]}"
                            timestamp = datetime.strptime(timestamp_str, "%Y%m%d_%H%M%S")
                            
                            highlight_dirs.append({
                                'name': item.name,
                                'timestamp': timestamp,
                                'formatted_time': timestamp.strftime("%Y-%m-%d %H:%M:%S"),
                                'view_url': f"/output/{item.name}/index.html",
                                'task_id': parts[3] if len(parts) > 3 else 'unknown'
                            })
                        except ValueError:
                            # Skip directories with invalid timestamp format
                            continue
        
        # Sort by timestamp, newest first
        highlight_dirs.sort(key=lambda x: x['timestamp'], reverse=True)
        
        return render_template('results.html', highlights=highlight_dirs)
        
    except Exception as e:
        logger.error(f"Error listing results: {e}")
        return render_template('error.html', error=str(e)), 500

@app.route('/output/<path:filename>')
def serve_output(filename):
    # Serve files from the output directory
    output_dir = Path(get_setting("output_dir", "output"))
    if not output_dir.is_absolute():
        # Make it relative to the current working directory
        output_dir = Path.cwd() / output_dir
    return send_from_directory(str(output_dir), filename)

if __name__ == '__main__':
    app.run(debug=True, port=5002)
